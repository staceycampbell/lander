#! /bin/sh
#Path: uunet!tektronix!tekgen!tekred!games
#From: games@tekred.CNA.TEK.COM
#Newsgroups: comp.sources.games
#Subject: v06i070:  lander - lunar lander simulation for BSD and SysV
#Message-ID: <3925@tekred.CNA.TEK.COM>
#Date: 1 May 89 18:47:48 GMT
#Sender: billr@tekred.CNA.TEK.COM
#Lines: 1178
#Approved: billr@saab.CNA.TEK.COM
#
#Submitted-by: stacey@hcrvax.UUCP
#Posting-number: Volume 6, Issue 70
#Archive-name: lander
#
#
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 1)."
# Contents:  README Makefile consts.h funcs.h land.c lander.6 move.c
#   score.c screen.c
# Wrapped by billr@saab on Mon May  1 11:44:02 1989
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(912 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
XThis is a C implementation of the old ``lunar lander''
Xgame seen in amusement arcades in the mid-seventies.
X
XThis version has been ported to various System 5.3
Xsystems, namely 386/ix and HCR's port of System 5.3 to
Xa VAX.  It has also been ported to a version of BSD.
X
XLander utilises some of the nifty SysV.3 curses capabilities
Xsuch as line drawing.  Anyone using an ANSI compatible
Xterminal should see the full effect.  Assorted Visual
Xterminals will give the same results with a decent terminfo
Xfile.  BSD people are stuck with their implementation
Xof curses, but it still looks kind of okay.
X
XLander uses a high score file that is writable by
Xall users running the program, please edit the Makefile to
Xensure a valid name is used.  Lander will attempt to
Xcreate the HS file the first time the game is run and
Xa successful landing is completed.
X
XPlease read the copyright info at the bottom of the man page.
END_OF_FILE
if test 912 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(771 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X# Lander Makefile
X
X# System 5.3
X#
X# OSV=SYS5_3
X# LIBS= -lcurses -lm
X# RAND_L=RAND_SYS5
X
X# BSD Unix
X#
XOSV=BSD
XLIBS= -lcurses -ltermcap -lm
XRAND_L=RAND_BSD
X
X# System 5.2 or earlier (untested but should work)
X#
X# OSV=BSD
X# LIBS= -lcurses -lm
X# RAND_L=RAND_SYS5
X
X# high score file name - change for your system
XHSFILE= /usr/games/lib/lander.hs
X
XOBJS= land.o screen.o move.o score.o
XSRC= land.c screen.c move.c score.c
XINC= consts.h funcs.h
XBIN= $(HOME)/bin
XOPT= -O
XHSSTRING='"$(HSFILE)"'
XCFLAGS= $(OPT) -D$(RAND_L) -DHS_FILE=$(HSSTRING) -D$(OSV)
X
Xlander: $(OBJS)
X	cc -o lander $(CFLAGS) $(OBJS) $(LIBS)
X
X$(OBJS): consts.h
X
Xshar:
X	xshar README lander.6 Makefile $(SRC) $(INC) > lander.shar
X
Xlint:
X	lint $(CFLAGS) $(SRC)
X
Xinstall: lander
X	rm -f $(BIN)/lander
X	cp lander $(BIN)
END_OF_FILE
if test 771 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'consts.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'consts.h'\"
else
echo shar: Extracting \"'consts.h'\" \(1116 characters\)
sed "s/^X//" >'consts.h' <<'END_OF_FILE'
X#define ALTITUDE_INIT 1500.0                   /* initial altitude in metres */
X#define LANDSCAPE_WIDTH 5000.0             /* initial screen width in metres */
X#define PAD '='                    /* landing pad char in template of screen */
X#define CRASH 2                                           /* status of crash */
X#define LANDED 1                 /* status of potentially successful landing */
X#define FLYING 0                                  /* status of flying lander */
X#define GRAVITY 3.2   /* rate of descent in metres per second due to gravity */
X#define ACCEPTABLE 5.0   /* acceptable landing velocity in metres per second */
X#define SCR_Y 22                            /* height of lunarscape in chars */
X#define SCR_X 76                             /* width of lunarscape in chars */
X               /* macro to determine of y and x are legal screen coordinates */
X#define LEGAL_YX(y, x) ((y) < SCR_Y && (x) < SCR_X && (y) >= 0 && (x) >= 0)
X#define SCR_ADJ(y) (y + 1)   /* difference between lunarscape y and screen y */
X#define MAX_PADS 20        /* maximum number of landing pads in a lunarscape */
END_OF_FILE
if test 1116 -ne `wc -c <'consts.h'`; then
    echo shar: \"'consts.h'\" unpacked with wrong size!
fi
# end of 'consts.h'
fi
if test -f 'funcs.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'funcs.h'\"
else
echo shar: Extracting \"'funcs.h'\" \(210 characters\)
sed "s/^X//" >'funcs.h' <<'END_OF_FILE'
Xvoid UpdateScore();
Xvoid ScWrite();
Xvoid ScReadDisplay();
Xvoid InitScore();
Xvoid InitialiseScreen();
Xvoid DrawScreen();
Xvoid InitMoves();
Xvoid GetMove();
Xint MoveLander();
Xvoid PressSpace();
Xvoid DrawScreen();
END_OF_FILE
if test 210 -ne `wc -c <'funcs.h'`; then
    echo shar: \"'funcs.h'\" unpacked with wrong size!
fi
# end of 'funcs.h'
fi
if test -f 'land.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'land.c'\"
else
echo shar: Extracting \"'land.c'\" \(6926 characters\)
sed "s/^X//" >'land.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <math.h>
X#include <curses.h>
X#include "consts.h"
X#include "funcs.h"
X
X#define INIT_DX_VAL 166.0                     /* initial horizontal velocity */
X#define INIT_DX_INC 13.0   /* rate of init hor vel increase between landings */
X#define INIT_DY_VAL 0.0                         /* initial vertical velocity */
X#define INIT_DY_INC 3.0    /* rate of decrease in vert velocity b/w landings */
X
Xextern int LastLegalY, LastLegalX;
Xextern int Score, BestScore;
Xextern double FuelDec;
X
Xvoid EndCurses();
Xvoid StartLander();
Xint FlyLander();
Xint CleanUp();
Xvoid Explode();
X
Xint Landings;
Xint BSLandings = 0;
X
Xmain(argc, argv)
X
Xint argc;
Xchar *argv[];
X
X	{
X	double init_dy;                  /* initial rate of fall per landing */
X	double init_dx;           /* initial horizontal velocity per landing */
X	WINDOW *screen;                        /* main display curses window */
X	int LanderStatus;              /* status of lander at end of landing */
X
X	InitialiseScreen(&screen);                   /* do basic screen init */
X	InitScore();
X	do	{
X                                          /* init screen and lander for game */
X		StartLander(&init_dy, &init_dx);
X		do	{
X			InitMoves(screen);    /* init lander for one landing */
X			DrawScreen(screen);   /* init screen for one landing */
X			LanderStatus = FlyLander(screen, init_dy, init_dx);
X			init_dy -= INIT_DY_INC;       /* make landing harder */
X			init_dx += INIT_DX_INC;
X			} while (LanderStatus == LANDED);     /* until crash */
X		} while (CleanUp(screen));  /* while user wants another game */
X	EndCurses(screen);                           /* final screen cleanup */
X	return 0;
X	}
X
X/*
X** StartLander() - initialise a new game.
X*/
X
Xextern int Score;
X
Xstatic void StartLander(init_dy, init_dx)
X
Xdouble *init_dy, *init_dx;
X
X	{
X	Landings = 0;
X	Score = 0;
X	FuelDec = 0.0;
X	*init_dy = INIT_DY_VAL;
X	*init_dx = INIT_DX_VAL;
X	}
X
X/*
X** EndCurses() - final cleanup before program exit.
X*/
X
Xstatic void EndCurses(screen)
X
X	{
X	nodelay(screen, FALSE);                        /* switch off nodelay */
X	wmove(screen, 1, 0);
X	wclrtoeol(screen);                             /* display best score */
X	wprintw(screen, "--Best Score: %d ", BestScore);
X	wprintw(screen, "with %d landing%s - press space--", BSLandings,
X	    BSLandings == 1 ? "" : "s");
X	wrefresh(screen);
X	while (wgetch(screen) != ' ');
X	endwin();                                        /* shut down curses */
X	}
X
Xstatic int CleanUp(screen)
X
XWINDOW *screen;
X
X	{
X	char ch;
X
X	nodelay(screen, FALSE);
X	if (Score > BestScore)
X		{
X		BestScore = Score;
X		BSLandings = Landings;
X		}
X	ScWrite(screen);
X	ScReadDisplay(screen);
X	wmove(screen, 1, 0);
X	wprintw(screen, "--Game Over - Safe Landings: %d - another game?--",
X		Landings);
X	wrefresh(screen);
X	do	{
X		ch = wgetch(screen);
X		} while (ch != 'Y' && ch != 'y' && ch != ' ' && ch != 'n');
X	return ch == 'Y' || ch == 'y' || ch == ' ';
X	}
X
Xstatic int FlyLander(screen, y_move, x_move)
X
XWINDOW *screen;
Xdouble y_move, x_move;
X
X	{
X	int land_stat;
X	double altitude = ALTITUDE_INIT;
X	double longditude = 0.0;
X
X	for (land_stat = FLYING; land_stat == FLYING;)
X		{
X		sleep(1);
X		GetMove(screen, &y_move, &x_move);
X		land_stat = MoveLander(screen, altitude, longditude);
X		switch (land_stat)
X		    {
X		    case FLYING :
X			y_move -= GRAVITY;
X			altitude += y_move;
X			if (altitude < 0.0)
X				altitude = 0.0;
X			longditude += x_move;
X			break;
X		    case LANDED :
X			if (y_move < -(ACCEPTABLE))
X				{
X				Explode(screen, LastLegalY, LastLegalX);
X				land_stat = CRASH;
X				}
X			else
X				UpdateScore(screen);
X			break;
X		    case CRASH :
X			Explode(screen, LastLegalY, LastLegalX);
X			break;
X		    }
X		wmove(screen, 0, 0);
X		wclrtoeol(screen);
X		wprintw(screen,
X		    "alt: %8.3f X: %8.2f dY: %7.3f dX: %7.3f Score: %5d",
X		    altitude, longditude, y_move, x_move, Score);
X		wrefresh(screen);
X		}
X	if (land_stat == LANDED)
X		{
X		++Landings;
X		nodelay(screen, FALSE);
X		wmove(screen, 1, 0);
X		wprintw(screen, "--Safe Landing Number: %d", Landings);
X		waddstr(screen, " - press space bar--");
X#ifdef BSD
X		wrefresh(screen);
X#endif
X		while (wgetch(screen) != ' ');
X		nodelay(screen, TRUE);
X		}
X	return land_stat;
X	}
X
X#define SEQ_COUNT (sizeof(sequenceA) / sizeof(sequenceA[0]))
X#define AVERAGE 9
X#define DEVIATION 4
X#define MAX_PARTS (AVERAGE + DEVIATION)
Xstatic char sequenceA[] = {'-', '/', '|', '\\'};
Xstatic char sequenceB[] = {'-', '\\', '|', '/'};
X
Xstatic void Explode(screen, Y_bang, X_bang)
X
XWINDOW *screen;
Xint Y_bang, X_bang;
X
X	{
X	int particles, i, new_y, new_x, draw_y, draw_x, touched, toy, tox;
X	int overlay[SCR_Y][SCR_X];
X#ifdef BSD
X	int old_chs[SCR_Y][SCR_X];
X#else
X	chtype old_chs[SCR_Y][SCR_X];
X#endif
X	double x_inc;
X	struct paths_t {
X		double x_mult;
X		double y_mult;
X		double x;
X		int old_y;
X		int old_x;
X		int seq_no;
X		char *sequence;
X		} paths[MAX_PARTS];
X	struct paths_t *path;
X	long lrand48(), time();
X	double drand48();
X	void srand48();
X
X	wstandout(screen);
X	mvwaddch(screen, SCR_ADJ(Y_bang), X_bang, '*');
X	wstandend(screen);
X	wrefresh(screen);
X	srand48(time((long *) 0));
X	memset((char *)overlay, 0, sizeof(overlay));
X	particles = (AVERAGE + lrand48() % DEVIATION);
X	x_inc = M_PI_2 * (drand48() * 0.01 + 0.01);
X	for (i = 0; i < particles; ++i)
X		{
X		path = &paths[i];
X		path->x = 0.0;
X		path->x_mult = drand48() * (double) SCR_X * 0.2;
X		path->y_mult = drand48() * (double) SCR_Y * 1.1 + 5.0;
X		path->old_y = -1;
X		path->old_x = -1;
X		path->seq_no = lrand48() % SEQ_COUNT;
X		path->sequence = i & 1 ? sequenceA : sequenceB;
X		flash();
X		}
X	while (paths[0].x < M_PI)
X		for (i = 0; i < particles; ++i)
X			{
X			touched = 0;
X			path = &paths[i];
X			new_x = path->x * path->x_mult + 0.5;
X			if (i & 1)
X				new_x = -new_x;
X			new_y = sin(path->x) * path->y_mult + 0.5;
X			draw_y = Y_bang - new_y;
X			draw_x = X_bang + new_x;
X			toy = path->old_y;
X			tox = path->old_x;
X			if (LEGAL_YX(toy, tox))
X				if (!(--overlay[toy][tox]))
X					{
X					touched = 1;
X					mvwaddch(screen, SCR_ADJ(toy), tox,
X					    old_chs[toy][tox]);
X					}
X			if (LEGAL_YX(draw_y, draw_x))
X				{
X				wmove(screen, SCR_ADJ(draw_y), draw_x);
X				if (!overlay[draw_y][draw_x])
X					old_chs[draw_y][draw_x] = winch(screen);
X				waddch(screen,
X				    path->sequence[path->seq_no++ % SEQ_COUNT]);
X				++overlay[draw_y][draw_x];
X				touched = 1;
X				}
X			if (touched)
X				{
X#ifdef SYS5_3
X				flushinp();
X#endif
X				wrefresh(screen);
X				}
X			path->old_y = draw_y;
X			path->old_x = draw_x;
X			path->x += x_inc;
X			}
X	for (i = 0; i < particles; ++i)
X		{
X		path = &paths[i];
X		toy = path->old_y;
X		tox = path->old_x;
X		if (LEGAL_YX(toy, tox))
X			mvwaddch(screen, SCR_ADJ(toy), tox, old_chs[toy][tox]);
X		}
X	wrefresh(screen);
X	}
X
X#if defined(RAND_BSD)
Xstatic long lrand48()
X
X	{
X	long random();
X
X	return random();
X	}
X
Xstatic void srand48(seed)
X
Xlong seed;
X
X	{
X	srandom((int) seed);
X	}
X
X#define PERIOD (4096 - 1)
X
Xstatic double drand48()
X
X	{
X	return random() % PERIOD / (double) PERIOD;
X	}
X#endif
END_OF_FILE
if test 6926 -ne `wc -c <'land.c'`; then
    echo shar: \"'land.c'\" unpacked with wrong size!
fi
# end of 'land.c'
fi
if test -f 'lander.6' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lander.6'\"
else
echo shar: Extracting \"'lander.6'\" \(1205 characters\)
sed "s/^X//" >'lander.6' <<'END_OF_FILE'
X.TH Lander 6l
X.SH NAME
Xlander \- the arcade game
X.SH DESCRIPTION
X.I Lander
Xis an implementation of the ancient ``lunar lander'' arcade
Xgame.
X.PP
XThe object of the game is to gently land a lunar module on
Xthe lunar surface.  Landing with a vertical velocity greater
Xthan 5 metres per second will generally result in fragmentation of the
Xlander and loss of cabin pressure!
X.PP
XScoring is based on which landing pad you choose, how much
Xfuel you conserved during landing and the difficulty factor
Xof landing from higher entry velocities as the game progresses.
X.PP
XOperating instructions are provided on the initial screen of
X.I lander.
XA high score file is maintained.
X.SH BUGS
XNone known, but please send bug reports to {utzoo,utcsri,lsuc}!hcr!stacey.
X.SH AUTHOR
XStacey Campbell \- HCR Corporation, Toronto, Canada, 1989.
X.SH DISCLAIMER
XLander is copyright 1989 by HCR Corporation, Toronto, Ontario, Canada.
XPermission to use, copy, modify, and distribute this software and
Xits documentation for any purpose and without fee is hereby
Xgranted, provided that the above copyright notice appear in all
Xcopies.
X.PP
XHCR  Corporation  disclaims all  warranties with regard to
Xthis software. Use at your own risk.
END_OF_FILE
if test 1205 -ne `wc -c <'lander.6'`; then
    echo shar: \"'lander.6'\" unpacked with wrong size!
fi
# end of 'lander.6'
fi
if test -f 'move.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'move.c'\"
else
echo shar: Extracting \"'move.c'\" \(1760 characters\)
sed "s/^X//" >'move.c' <<'END_OF_FILE'
X#include <fcntl.h>
X#include <stdio.h>
X#include <ctype.h>
X#include <math.h>
X#include <curses.h>
X#include "consts.h"
X#include "funcs.h"
X
X#if defined(BSD) && ! defined(O_NDELAY)
X#define NO_INP -1
X#else
X#define NO_INP EOF
X#endif
X
X#define FABS_M(x) ((x) >= -1.0 ? 1.0 : -(x))
X#define FUEL_INIT 5000.0
X#define FUEL_DRAIN 450.0
X#define FUEL_MIN 100.0
X
Xdouble Fuel;
Xdouble FuelDec = 0.0;
X
Xstatic double Power;
Xstatic double PowerSet[] = {0.0, 0.01, 0.1, 0.5, 1.0, 2.0, 5.0, 10.0,
X    15.0, 20.0};
Xstatic double att1p, att2p, att3p;
X
Xvoid InitMoves(screen)
X
XWINDOW *screen;
X
X	{
X	att1p = 0.0;
X	att2p = 0.0;
X	att3p = 0.0;
X	Power = 0.0;
X	Fuel = FUEL_INIT - FuelDec;
X	if (Fuel < FUEL_MIN)
X		Fuel = FUEL_MIN;
X	FuelDec += FUEL_DRAIN;
X	nodelay(screen, TRUE);
X	}
X
Xvoid GetMove(screen, y_delta, x_delta)
X
XWINDOW *screen;
Xdouble *y_delta, *x_delta;
X
X	{
X	int ch, index;
X	double y_delta_inc;
X
X	if (Fuel > 0.0)
X		{
X		wrefresh(screen);
X		while ((ch = wgetch(screen)) != NO_INP)
X			{
X#ifdef BSD
X			ch &= 0x7F;
X#endif
X			if (isdigit(ch))
X				{
X				index = ch - '0';
X				Power = PowerSet[index];
X				}
X			else
X				switch (ch)
X			    	{
X			    	case 'z' :
X					att1p = Power;
X					break;
X			    	case 'x' :
X					att2p = Power;
X					break;
X			    	case 'c' :
X					att3p = Power;
X					break;
X			    	default :
X					flash();
X					break;
X			    	}
X			}
X		*x_delta += att1p;
X		y_delta_inc = att2p * (log10(FABS_M(*y_delta)) / GRAVITY);
X		*y_delta += y_delta_inc;
X		*x_delta -= att3p;
X		Fuel -= att3p + att2p + att1p;
X		if (Fuel < 0.0)
X			att3p = att2p = att1p = Power = Fuel = 0.0;
X		}
X	wmove(screen, LINES - 1, 0);
X	wclrtoeol(screen);
X	wprintw(screen,
X            "Thrust - L: %5.2f vert: %7.4f R: %5.2f Pow: %5.2f Fuel: %7.2f",
X	    att1p, att2p, att3p, Power, Fuel);
X	wrefresh(screen);
X	}
END_OF_FILE
if test 1760 -ne `wc -c <'move.c'`; then
    echo shar: \"'move.c'\" unpacked with wrong size!
fi
# end of 'move.c'
fi
if test -f 'score.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'score.c'\"
else
echo shar: Extracting \"'score.c'\" \(4844 characters\)
sed "s/^X//" >'score.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <curses.h>
X#include "consts.h"
X#include "funcs.h"
X
X#define HEADER "Scores"
X#define NAME_LEN 20
X#define HS_ENTRIES 10
X#define SC_WIN_LEN 16
X#define SPC_LINE (SC_WIN_LEN - 2)
X
Xtypedef struct score_pad_t {
X	int y;
X	int start_x;
X	int end_x;
X	} score_pad_t;
Xtypedef struct score_t {
X	int score;
X	char name[NAME_LEN];
X	} score_t;
X
Xextern double Fuel;
Xextern int PadScore[];
Xextern int BSLandings, Landings;
Xextern char *Template[];
Xextern int LastLegalY, LastLegalX;
X
Xscore_pad_t ScorePad[MAX_PADS];
Xint Score;
Xint BestScore = 0;
X
Xstatic char *HSFile = HS_FILE;
Xstatic int TotalPads;
X
Xvoid ScDisplayErr();
Xint ScCmp();
X
Xvoid ScReadDisplay(back_win)
X
XWINDOW *back_win;
X
X	{
X	int old_y, old_x, items, i;
X	WINDOW *score_win;
X	FILE *fp;
X	score_t score_pad[HS_ENTRIES];
X
X	if ((fp = fopen(HSFile, "r")) == NULL)
X		{
X		ScDisplayErr(back_win, "Unable to display HS file.");
X		return;
X		}
X	getyx(back_win, old_y, old_x);
X	wmove(back_win, 0, 0);
X	wrefresh(back_win);
X	score_win = newwin(SC_WIN_LEN, 25, 2, 5);
X	werase(score_win);
X	box(score_win, 0, 0);
X	items = fread((char *)score_pad, sizeof(score_t), HS_ENTRIES, fp);
X	fclose(fp);
X	if (items == 0)
X		{
X		mvwaddstr(score_win, 5, 1, "HS file empty.");
X		PressSpace(back_win, old_y, old_x, score_win, SPC_LINE, 1);
X		return;
X		}
X	mvwaddstr(score_win, 1, (25 - sizeof(HEADER)) / 2, HEADER);
X	wrefresh(score_win);
X	for (i = 0; i < items; ++i)
X		{
X		wmove(score_win, 3 + i, 1);
X		wprintw(score_win, "%4d %s", score_pad[i].score,
X		    score_pad[i].name);
X		}
X	PressSpace(back_win, old_y, old_x, score_win, SPC_LINE, 1);
X	}
X
Xvoid ScWrite(back_win)
X
XWINDOW *back_win;
X
X	{
X	int items;
X	FILE *fp;
X	char *user;
X	score_t score_pad[HS_ENTRIES + 1];
X	void qsort();
X	char *getenv();
X
X	if (Score == 0)
X		return;
X	if ((fp = fopen(HSFile, "r")) == NULL)
X		{
X		ScDisplayErr(back_win, "Unable to read HS file.");
X		ScDisplayErr(back_win, "Attempting to create HS file.");
X		if (creat(HSFile, 0777) == -1)
X			{
X			ScDisplayErr(back_win,
X			    "Unable to create HS file, check pathname.");
X			return;
X			}
X		}
X	if ((fp = fopen(HSFile, "r")) == NULL)
X		{
X		ScDisplayErr(back_win, "Unable to read new HS file.");
X		return;
X		}
X	items = fread((char *)score_pad, sizeof(score_t), HS_ENTRIES, fp);
X	fclose(fp);
X	if ((user = getenv("LOGNAME")) == NULL)
X		{
X		ScDisplayErr(back_win, "Environment var LOGNAME must be set");
X		return;
X		}
X	strcpy(score_pad[items].name, user);
X	score_pad[items].score = Score;
X	++items;
X	qsort((char *)score_pad, items, sizeof(score_t), ScCmp);
X	if (items > HS_ENTRIES)
X		items = HS_ENTRIES;
X	if ((fp = fopen(HSFile, "w")) == NULL)
X		{
X		ScDisplayErr(back_win, "Unable to write HS file.");
X		return;
X		}
X	if (fwrite((char *)score_pad, sizeof(score_t), items, fp) == 0)
X		ScDisplayErr(back_win, "No HS entries written.");
X	fclose(fp);
X	}
X
Xstatic int ScCmp(sc_rec1, sc_rec2)
X
Xscore_t *sc_rec1, *sc_rec2;
X
X	{
X	if (sc_rec1->score < sc_rec2->score)
X		return 1;
X	if (sc_rec1->score > sc_rec2->score)
X		return -1;
X	return 0;
X	}
X
Xvoid PressSpace(back_win, y, x, cur_win, sy, sx)
X
XWINDOW *back_win, *cur_win;
Xint y, x, sy, sx;
X
X	{
X	mvwaddstr(cur_win, sy, sx, "--press space--");
X	wrefresh(cur_win);
X	while (wgetch(cur_win) != ' ');
X	delwin(cur_win);
X	wmove(back_win, y, x);
X	touchwin(back_win);
X	wrefresh(back_win);
X	}
X
Xstatic void ScDisplayErr(back_win, str)
X
XWINDOW *back_win;
Xchar *str;
X
X	{
X	int old_y, old_x, win_len;
X	WINDOW *err_win;
X
X	getyx(back_win, old_y, old_x);
X	wmove(back_win, 0, 0);
X	wrefresh(back_win);
X	win_len = strlen(str) + 2;
X	err_win = newwin(3, win_len, LINES / 2 - 2, (COLS - win_len - 2) / 2);
X	box(err_win, 0, 0);
X	mvwaddstr(err_win, 1, 1, str);
X	wrefresh(err_win);
X	sleep(3);
X	delwin(err_win);
X	wmove(back_win, old_y, old_x);
X	touchwin(back_win);
X	wrefresh(back_win);
X	}
X
Xvoid UpdateScore(screen)
X
XWINDOW *screen;
X
X	{
X	int pad_i = 0, found = 0, fuel_bonus, diff_bonus;
X	char scr_buf[128];
X
X	while (pad_i < SCR_X && ! found)
X		{
X		found = LastLegalX >= ScorePad[pad_i].start_x &&
X			LastLegalX <= ScorePad[pad_i].end_x &&
X			ScorePad[pad_i].y == LastLegalY;
X		++pad_i;
X		}
X	--pad_i;
X	fuel_bonus = Fuel / 100.0 + 0.5;
X	sprintf(scr_buf, "Fuel bonus: %d", fuel_bonus);
X	mvwaddstr(screen, 3, 25, scr_buf);
X	wrefresh(screen);
X	diff_bonus = (Landings + 1) * 10;
X	sprintf(scr_buf, "Consecutive Landings Bonus: %d", diff_bonus);
X	mvwaddstr(screen, 4, 9, scr_buf);
X	wrefresh(screen);
X	Score += PadScore[pad_i] + fuel_bonus + diff_bonus;
X	}
X
Xvoid InitScore()
X
X	{
X	int i, j, pad_count = 0;
X	char *line;
X
X	for (i = 0; i < SCR_Y; ++i)
X		{
X		j = 0;
X		line = Template[i];
X		while (j < SCR_X)
X			{
X			if (line[j] == PAD)
X				{
X				ScorePad[pad_count].y = i;
X				ScorePad[pad_count].start_x = j;
X				while (j < SCR_X && line[j] == PAD)
X					++j;
X				if (j >= SCR_X)
X					--j;
X				ScorePad[pad_count].end_x = j;
X				++pad_count;
X				}
X			++j;
X			}
X		}
X	TotalPads = pad_count;
X	}
END_OF_FILE
if test 4844 -ne `wc -c <'score.c'`; then
    echo shar: \"'score.c'\" unpacked with wrong size!
fi
# end of 'score.c'
fi
if test -f 'screen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'screen.c'\"
else
echo shar: Extracting \"'screen.c'\" \(6384 characters\)
sed "s/^X//" >'screen.c' <<'END_OF_FILE'
X#include <signal.h>
X#include <fcntl.h>
X#include <stdio.h>
X#include <curses.h>
X#include "consts.h"
X#include "funcs.h"
X
X#define ALT_ADD(screen, y, x, ch) \
X	wmove(screen, y, x); \
X	waddch(screen, ch);
X#define STAND_ADD(screen, y, x, ch) \
X	wmove(screen, y, x); \
X	wstandout(screen); \
X	waddch(screen, ch); \
X	wstandend(screen);
X#define STAND_ALT_ADD(screen, y, x, ch) \
X	wstandout(screen); \
X	ALT_ADD(screen, y, x, ch); \
X	wstandend(screen);
X
Xchar *Template[] = {
X"                                                                            ",
X".                                                                          /",
X"<                                                                        /v+",
X"<                                                                       /+++",
X"<                                                                     /v++++",
X"<                            /====.                                   >+++++",
X"<                            `v30v<                                  /++++++",
X"<                             >++++.                                 >++++++",
X"<                             >++++<                                /+++++++",
X"<                             >++++<                               /++++++++",
X"+.                            >+++++.                              `++++++++",
X"+<                           /++++++<                               `+++++++",
X"+<                          /+++++++<                                >++++++",
X"+<                          >+++++++<                          /v.   >++++++",
X"+<                          >+++++++<                         /+++.  >++++++",
X"+<                          >+++++++'                         >+++<  >++++++",
X"++====.                /====+++++++<                          >+++<  >++++++",
X"++v30v<            /vvv+v15v+++++++<          /v.           /v++++<  >++++++",
X"+++++++v.       /vv++++++++++++++++<        /v+++====.      >++++++==+++++++",
X"+++++++++=======+++++++++++++++++++<      /v+++++v20v+======+++++++50+++++++",
X"+++++++++vv10vvv++++++++++++++++++++======++++++++++++vv15vv++++++++++++++++",
X"++++++++++++++++++++++++++++++++++++vv25vv++++++++++++++++++++++++++++++++++"};
X
Xint PadScore[MAX_PADS] = {30, 30, 15, 20, 50, 10, 15, 25};
Xint LastLegalY, LastLegalX;
X
X#ifdef BSD
Xtypedef char chtype_port_t;
X#else
Xtypedef chtype chtype_port_t;
X#endif
X
Xstatic chtype_port_t LineMap[128] = {0};
Xstatic int Old_Y, Old_X;
X
Xvoid Introduction();
Xvoid dumpcore();
Xvoid zap();
X
Xvoid InitialiseScreen(init_scr)
X
XWINDOW **init_scr;
X
X	{
X	register WINDOW *screen;
X
X	signal(SIGINT, zap);
X	signal(SIGQUIT, dumpcore);
X	initscr();
X	noecho();
X	cbreak();
X	*init_scr = stdscr;
X	screen = *init_scr;
X#ifdef BSD
X	LineMap['\''] = '+';
X	LineMap['.'] = '+';
X	LineMap['|'] = '|';
X	LineMap['-'] = '-';
X	LineMap['/'] = '+';
X	LineMap['`'] = '+';
X	LineMap['+'] = '+';
X	LineMap['>'] = '+';
X	LineMap['<'] = '+';
X	LineMap['^'] = '+';
X	LineMap['v'] = '+';
X	LineMap[PAD] = '=';
X#else
X	LineMap['\''] = ACS_LRCORNER;
X	LineMap['.'] = ACS_URCORNER;
X	LineMap['|'] = ACS_VLINE;
X	LineMap['-'] = ACS_HLINE;
X	LineMap['/'] = ACS_ULCORNER;
X	LineMap['`'] = ACS_LLCORNER;
X	LineMap['+'] = ACS_PLUS;
X	LineMap['>'] = ACS_LTEE;
X	LineMap['<'] = ACS_RTEE;
X	LineMap['^'] = ACS_BTEE;
X	LineMap['v'] = ACS_TTEE;
X	LineMap[PAD] = ACS_HLINE;
X#endif
X	Introduction(screen);
X	}
X
Xvoid DrawScreen(screen)
X
XWINDOW *screen;
X
X	{
X	register int i, j, scr_i;
X	chtype_port_t map;
X	char *line, ch;
X
X	werase(screen);
X	for (i = 0; i < SCR_Y; ++i)
X		{
X		line = Template[i];
X		scr_i = i + 1;
X		for (j = 0; j < SCR_X; ++j)
X			{
X			ch = *(line + j);
X			map = LineMap[ch];
X			if (map)
X				if (ch == PAD)
X					{
X					STAND_ALT_ADD(screen, scr_i, j, map);
X					}
X				else
X					{
X					ALT_ADD(screen, scr_i, j, map);
X					}
X			else
X				if (ch == PAD)
X					{
X					STAND_ADD(screen, scr_i, j, ch);
X					}
X				else
X					mvwaddch(screen, scr_i, j, ch);
X			}
X		}
X	wrefresh(screen);
X	LastLegalY = SCR_ADJ(0);
X	LastLegalX = 0;
X	Old_Y = Old_X = -1;
X	}
X
Xint MoveLander(screen, land_y, land_x)
X
XWINDOW *screen;
Xdouble land_y, land_x;
X
X	{
X	int y, x, touchup = 0, screen_y, new_legal;
X	double y_real, x_real;
X	char ch;
X
X	y_real = (ALTITUDE_INIT - land_y) / ALTITUDE_INIT * (double) SCR_Y;
X	x_real = land_x / LANDSCAPE_WIDTH * (double) SCR_X;
X	y = y_real + 0.5;
X	x = x_real + 0.5;
X	new_legal = LEGAL_YX(y, x);
X	if (y != Old_Y || x != Old_X)
X		{
X		if (LEGAL_YX(Old_Y, Old_X))
X			{
X			mvwaddch(screen, SCR_ADJ(Old_Y), Old_X, '.');
X			touchup = 1;
X			}
X		if (new_legal)
X			{
X			screen_y = SCR_ADJ(y);
X#ifdef BSD
X			ALT_ADD(screen, screen_y, x, '$');
X#else
X			ALT_ADD(screen, screen_y, x, ACS_TTEE);
X#endif
X			wmove(screen, screen_y, x);
X			LastLegalY = y;
X			LastLegalX = x;
X			touchup = 1;
X			}
X		}
X	if (touchup)
X		wrefresh(screen);
X	Old_Y = y;
X	Old_X = x;
X	if (new_legal)
X		{
X		ch = *(Template[y] + x);
X		if (ch == PAD)
X			return LANDED;
X		if (ch != ' ')
X			return CRASH;
X		}
X	else
X		return CRASH;
X	return FLYING;
X	}
X
Xstatic void zap()
X
X	{
X	endwin();
X	fcntl(fileno(stdin), F_SETFL, 0);
X	exit(1);
X	}
X
Xstatic void dumpcore()
X
X	{
X	fcntl(fileno(stdin), F_SETFL, 0);
X	endwin();
X	signal(SIGQUIT, SIG_DFL);
X	kill(getpid(), SIGQUIT);
X	pause();
X	}
X
X#define L0 "Lunar Lander"
X#define L1 "The classic arcade game comes to Unix."
X#define L2 "Controls:"
X#define L3 "'0'-'9' - power level"
X#define L4 "'z' - set left retro rocket to power level"
X#define L5 "'x' - set vertical thrust to power level"
X#define L6 "'c' - set right retro to power level"
X#define L7 "--press space to start game--"
X#define L8 "Stacey Campbell at HCR, 1989"
X#define CENTRE(win, line, str) mvwaddstr(win, line, (COLS - sizeof(str)) / 2, \
X	str)
X
Xstatic void Introduction(screen)
X
XWINDOW *screen;
X
X	{
X	werase(screen);
X	CENTRE(screen, 2, L0);
X	CENTRE(screen, 5, L1);
X	CENTRE(screen, 9, L2);
X	CENTRE(screen, 11, L3);
X	CENTRE(screen, 12, L4);
X	CENTRE(screen, 13, L5);
X	CENTRE(screen, 14, L6);
X	CENTRE(screen, 18, L8);
X	CENTRE(screen, 20, L7);
X#ifdef BSD
X	wrefresh(screen);
X#endif
X	while (wgetch(screen) != ' ');
X	}
X
X#ifdef BSD
X
Xint flash()
X
X	{
X	putchar(7);
X	}
X
X#ifndef FNDELAY
X#define FNDELAY O_NDELAY
X#endif
X
Xint nodelay(win, flag)
X
XWINDOW *win;
Xint flag;
X
X	{
X	int res;
X
X	res = fcntl(fileno(stdin), F_GETFL, 0);
X	if (flag)
X		{
X		res |=  FNDELAY;
X		fcntl(fileno(stdin), F_SETFL, res);
X		}
X	else
X		{
X		res &= ~FNDELAY;
X		fcntl(fileno(stdin), F_SETFL, res);
X		}
X	return 0;
X	}
X#endif
END_OF_FILE
if test 6384 -ne `wc -c <'screen.c'`; then
    echo shar: \"'screen.c'\" unpacked with wrong size!
fi
# end of 'screen.c'
fi
echo shar: End of archive 1 \(of 1\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have the archive.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
